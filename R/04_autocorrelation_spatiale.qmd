---
title: "Analyse de l'autocorr√©lation spatiale"
author: "Antoine Peris"
format: html
editor: visual
lang: fr
---

## Introduction

### La notion d'autocorr√©lation spatiale

L‚Äô**autocorr√©lation spatiale** est une notion cl√© en g√©ographie et en analyse spatiale. Elle mesure le degr√© de **ressemblance ou de diff√©rence** des valeurs d‚Äôune variable selon leur proximit√© g√©ographique.

Elle permet de r√©pondre √† la question : *les unit√©s spatiales voisines ont-elles tendance √† pr√©senter des valeurs similaires ou diff√©rentes ?*

Une autocorr√©lation spatiale **positive** se traduit par des regroupements de valeurs similaires (clusters de hauts ou bas revenus, par exemple), tandis qu‚Äôune autocorr√©lation **n√©gative** indique que des valeurs √©lev√©es sont entour√©es de valeurs faibles, et vice versa.

L‚Äô√©tude de l‚Äôautocorr√©lation spatiale permet ainsi d‚Äôidentifier des **zones homog√®nes**, des **points chauds** ou des **anomalies locales**, fournissant un √©clairage sur la structure spatiale des ph√©nom√®nes √©tudi√©s.

Les indicateurs globaux, comme le Moran I, donnent une vue d‚Äôensemble, tandis que les indicateurs locaux (LISA) permettent de **localiser pr√©cis√©ment les clusters et les outliers**.

L'objectif de ce TD est d'apprendre √† mettre en place ces deux m√©thodes afin d'√©valuer le niveau d'autocorr√©lation spatiale du niveau de vie m√©dian communal dans une aire d'attraction.

### Pr√©paration de l'environnement de travail

Il est d'abord n√©cessaire de charger les packages classiques afin de charger et manipuler des donn√©es tabulaires et des donn√©es spatiales vectorielles. On ajoute √©galement **{ggplot2}** pour la visualisation et **{spdep}** pour l'analyse spatiale. Ce dernier package permet de travailler sur la d√©pendance spatiale en g√©rant notamment les matrices de poids.

```{r}
#| message: false
#| warning: false
library(sf)
library(dplyr)
library(ggplot2)
library(readr)
library(spdep)
```

On charge ensuite les deux couches de donn√©es n√©cessaire pour l'analyse de l‚Äôauto-corr√©lation spatiale des revenus m√©dians communaux √† l'√©chelle des AAV.

```{r}
#| message: false
#| warning: false
aav <- st_read("../data/aav2020.gpkg", quiet=T)
filosofi <- st_read("../data/filosofi_communes_2022.gpkg", quiet=T)
```

Pour ce tutoriel, nous allons nous focaliser sur la ville de Bordeaux. On va donc enregistrer son code dans une variable. Pour changer de ville, il suffira de modifier cette partie. On s√©lectionne ensuite la ligne de la couche `aav` qui correspond √† la ville d'int√©r√™t.

```{r}
aav_code = "006"
aav_geom <- aav %>% filter(aav2020==aav_code)
```

Ensuite, on r√©cup√®re toutes les communes de `filosofi` qui intersectent la g√©om√©trie de l'AAV. Pour cela, on transforme √† la vol√©e les communes en points afin d'acc√©l√©rer le traitement et de ne bien inclure que les communes √† l'int√©rieur du p√©rim√®tre.

```{r}
int <- st_intersects(st_point_on_surface(filosofi), aav_geom)
iris_aav <- filosofi[sapply(1:nrow(filosofi), function(x) length(int[[x]])>0),]
```

On effectue ensuite une rapide visualisation des revenus communaux.

```{r}
ggplot()+
  geom_sf(data = iris_aav, aes(fill=Q221))+
  scale_fill_fermenter(direction = 1)+
  theme_bw()+
  coord_sf(datum = NA)+
  labs(title = "Revenu m√©dian par unit√© de consommation")
```

Avant de continuer, on regarde rapidement s'il y a beaucoup de valeurs manquantes qui pourraient affecter l'analyse.

```{r}
#| message: false
#| warning: false
iris_aav %>% 
  as_tibble() %>% 
  summarise(nb_NA = sum(is.na(Q221)),
            pct_NA = mean(is.na(Q221))*100) %>% knitr::kable()
```

Ce n'est pas le cas, on les supprime donc du tableau.

```{r}
filo <- iris_aav %>% filter(!is.na(Q221))
```

## Calcul d'indicateurs d'auto-corr√©lation spatiale

### L'analyse globale

L'indicateur permettant de calculer l'auto-corr√©lation spatiale globale d'un jeu de donn√©es est le **I de Moran**. Le $I$ de Moran est un indicateur statistique qui mesure le **niveau d‚Äôautocorr√©lation spatiale** d‚Äôune variable, c‚Äôest-√†-dire la tendance qu‚Äôont des valeurs similaires (√©lev√©es ou faibles) √† se regrouper dans l‚Äôespace.

-   **I \> 0** : autocorr√©lation spatiale positive (les valeurs semblables se regroupent)

-   **I \< 0** : l'autocorr√©lation spatiale n√©gative (les valeurs dissemblables sont proches).

-   **I** $\approx$ **0** : absence d‚Äôautocorr√©lation spatiale (r√©partition al√©atoire).

Il s‚Äôappuie sur un **matrice de voisinage** pour quantifier comment les valeurs observ√©es se distribuent spatialement. La premi√®re √©tape de cette analyse est de construire une liste de voisins et de transformer cette liste en matrice de poids spatiaux.

```{r}
nb <- poly2nb(filo, queen = TRUE)
listw <- nb2listw(nb, style = "W") # (style W = lignes normalis√©es)
```

Une telle matrice prend la forme suivante.

```{r}
#| message: false
#| warning: false
#| dev: png
par(mar=c(0,0,0,0))
plot(st_geometry(filo), border="grey")
plot(nb, st_coordinates(st_centroid(filo)), col="red", add=TRUE)
```

Le calcul de l'indicateur repose sur trois √©tapes :

-   On commence par regarder si chaque commune a un revenu **plus √©lev√©** ou **plus faible** que la moyenne. On calcule donc $x_i-\overline{x}$.

-   Ensuite, on compare cette valeur aux √©carts des **communes voisines**, en utilisant une **matrice de voisinage** (listw dans le code), qui dit quelles communes sont voisines et avec quel poids.

-   Pour permettre la comparaison entre jeux de donn√©es, on divise par la somme des carr√©s des √©carts √† la moyenne.

L‚Äôid√©e du Moran I est alors de v√©rifier si les communes **√©lev√©es** sont entour√©es de communes **√©lev√©es** et les communes **faibles** sont entour√©es de communes **faibles**.

```{r}
# Diagramme de Moran
moran.plot(as.vector(scale(filo$Q221)), listw, labels = FALSE,
           xlab = "Revenu des communes",
           ylab = "Revenu des communes voisines")
```

Le **test de Moran** compare ensuite cet indicateur √† ce qu‚Äôon obtiendrait **si les revenus √©taient distribu√©s au hasard dans l‚Äôespace** par le biais de nombreuses permutations. Par exemple ci-dessous avec 999 permutations.

```{r}
res_mc <- moran.mc(filo$Q221, listw, nsim = 999)
res_mc
```

Le test montre une **autocorr√©lation spatiale fortement positive** du revenu des communes.

La valeur observ√©e du Moran I est **0.576**, ce qui indique que les communes tendent clairement √† ressembler √† leurs voisines : les communes √† revenu √©lev√© sont regroup√©es entre elles, et les communes √† revenu faible aussi.

Avec une p-value de **0.001**, cette autocorr√©lation est **hautement significative** : sur 1000 simulations al√©atoires, **aucune** n‚Äôa produit un I aussi √©lev√© que celui observ√©.

‚Üí On rejette donc l‚Äôhypoth√®se d‚Äôune r√©partition spatiale al√©atoire. Le revenu pr√©sente un fort clustering spatial, loin d‚Äô√™tre d√ª au hasard.

On peut visualiser le r√©sultat de ce test de la mani√®re suivante.

```{r}
# extraction des donn√©es
obs <- res_mc$statistic     # Moran I observ√©
sim <- res_mc$res           # valeurs simul√©es

# dataframe pour ggplot
df_mc <- data.frame(sim = sim)

ggplot(df_mc, aes(x = sim)) +
  geom_histogram(bins =50, fill = "grey80", color = "grey40") +
  geom_vline(xintercept = obs, color = "red", linewidth = 1.2) +
  labs(
    title = "Distribution de Moran I (Monte-Carlo)",
    subtitle = paste("Valeur observ√©e =", round(obs, 3)),
    x = "Moran I simul√©",
    y = "Fr√©quence"
  ) +
  theme_minimal()
```

### L'analyse locale

Les **LISA** (*Local Indicators of Spatial Association*) sont des indicateurs qui mesurent **l‚Äôautocorr√©lation spatiale locale**.\

Alors que le Moran I global r√©sume l‚Äôensemble du territoire avec une seule valeur, les LISA permettent de **localiser pr√©cis√©ment** o√π se trouvent :

-   des **clusters** de valeurs proches (ex. haut-haut, bas-bas),

-   des **outliers spatiaux** (ex. une commune √©lev√©e entour√©e de faibles, ou l‚Äôinverse).

Concr√®tement, les LISA identifient les zones o√π la variable √©tudi√©e est **significativement similaire ou dissemblable** √† celle des voisins.

Il se calcule √† l'aide de la fonction suivante :

```{r}
lisa <- localmoran(filo$Q221, listw)
```

On stocke ensuite les r√©sultats dans un tableau :

```{r}
filo <- filo %>% 
  mutate(
    Ii = lisa[,1],          # valeur du local Moran
    E_Ii = lisa[,2],        # esp√©rance
    Var_Ii = lisa[,3],      # variance
    Z_Ii = lisa[,4],        # statistique Z
    p_Ii = lisa[,5]         # p-value
  )
```

On calcule la **moyenne globale** de la variable `Q221` (niveau de vie).

Puis on cr√©e une nouvelle colonne `categorie` qui classe chaque commune selon le **type de cluster local** :

-   **High-High (HH)** : valeur √©lev√©e entour√©e de voisines √©lev√©es (autocorr√©lation positive significative)

-   **Low-Low (LL)** : valeur faible entour√©e de voisines faibles (autocorr√©lation positive significative)

-   **High-Low (HL)** : valeur √©lev√©e entour√©e de voisines faibles (autocorr√©lation n√©gative significative)

-   **Low-High (LH)** : valeur faible entour√©e de voisines √©lev√©es (autocorr√©lation n√©gative significative)

-   **Non significatif** : aucune autocorr√©lation locale significative (p-value \> 0.05)

Une commune est par exemple class√©e **High-High** lorsque sa valeur de `Q221` est **sup√©rieure ou √©gale √† la moyenne**, que son indicateur local Moran (`Ii`) est **positif** (indiquant une autocorr√©lation spatiale positive avec ses voisines) et que cette relation est **statistiquement significative** (p-value `p_Ii` ‚â§ 0,05).

```{r}
mean_Q <- mean(filo$Q221, na.rm = TRUE)

filo <- filo %>% 
  mutate(
    categorie = case_when(
      Q221 >= mean_Q & Ii > 0 & p_Ii <= 0.05 ~ "High-High",
      Q221 <  mean_Q & Ii > 0 & p_Ii <= 0.05 ~ "Low-Low",
      Q221 >= mean_Q & Ii < 0 & p_Ii <= 0.05 ~ "High-Low",
      Q221 <  mean_Q & Ii < 0 & p_Ii <= 0.05 ~ "Low-High",
      TRUE ~ "Non significatif"
    )
  )
```

On peut ensuite cartographier ce r√©sultat :

```{r}
lisa_palette <- c(
  "High-High" = "#E31A1C",     # rouge
  "Low-Low"   = "#1F78B4",     # bleu
  "Low-High"  = "#A6CEE3",     # bleu clair
  "High-Low"  = "#FB9A99",     # rose clair
  "Non significatif" = "grey80" # gris clair
)

ggplot(filo) +
  geom_sf(aes(fill = categorie), color = "grey40", size = 0.2) +
  scale_fill_manual(values = lisa_palette, name = "Clusters LISA\nRevenu Q221") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

On peut √©galement visualiser ces r√©sultats sous forme de nuage de points.

```{r}
#| message: false
#| warning: false
lag_Q221 <- lag.listw(listw, filo$Q221)

df_scatter <- filo %>% 
  st_drop_geometry() %>% 
  mutate(lag_Q221 = lag_Q221)

ggplot(df_scatter, aes(x = Q221, y = lag_Q221, color = categorie)) +
  geom_vline(xintercept = mean(lag_Q221))+
  geom_hline(yintercept = mean(filo$Q221))+
  geom_point(size = 2, alpha = 0.8) +
  scale_color_manual(values = lisa_palette) +
  geom_smooth(method = "lm", se = FALSE, color = "black", linetype = "dashed") +
  labs(
    title = "Moran Scatterplot du revenu Q221",
    x = "Q221 (revenu de la commune)",
    y = "Lag spatial de Q221 (moyenne des voisins)",
    color = "Cluster LISA"
  ) +
  theme_bw()
```

::: callout-note
### üìù Exercice : Analyse comparative de l'autocorr√©lation spatiale des revenus

Dans cet exercice, vous allez appliquer les diff√©rentes √©tapes abord√©es dans ce TD pour r√©aliser une **analyse comparative de l'autocorr√©lation spatiale des revenus**.

**Consignes :**

-   Choisissez soit **deux villes de taille similaire**, soit **une m√™me ville √† deux dates diff√©rentes** (vous disposez d‚Äôune couche de donn√©es avec le revenu m√©dian communal en 2014).

-   Pour chaque ville ou chaque p√©riode :

    1.  Calculez l‚Äôindicateur LISA sur la variable du revenu m√©dian communal.

    2.  Classez les communes selon les cat√©gories `High-High`, `Low-Low`, `High-Low`, `Low-High` ou `Non significatif`.

    3.  Visualisez les clusters sur une carte avec `ggplot2` ou `tmap`.

    4.  Comparez les r√©sultats : identifiez les clusters persistants, les diff√©rences spatiales et les √©ventuels outliers.
:::
