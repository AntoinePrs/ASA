---
title: "Fouille de donn√©es et cr√©ation d'objets spatiaux dans R"
author: "Antoine Peris"
format: html
editor: visual
lang: fr
---

## Objectif

Cette s√©ance a pour objectif de se rem√©morer des √©l√©ments de syntaxe de R (le chargement des donn√©es, la manipulation de tableaux, etc.) et de d√©couvrir deux familles d'outils tr√®s utiles dans la perspective d'acqu√©rir et de g√©rer des donn√©es spatiales :

-   les expressions r√©guli√®res (qui permettent d'aller r√©cup√©rer des informations de donn√©es textuelles peu structur√©es)

-   les objets spatiaux vectoriels (qui permettent de r√©aliser des traitements g√©omatiques en R, pr√©-requis pour de l'analyse spatiale)

Pour cela, nous travaillerons sur un projet concret : la construction d‚Äôun tableau de donn√©es sur les immeubles en p√©ril √† Bordeaux √† partir de arr√™t√©s publi√©s par le conseil municipal de la ville.

Nous partons de donn√©es brutes : le fichier est t√©l√©chargeable [ici](https://datahub.bordeaux-metropole.fr/explore/dataset/bor_arretes/export/).

## Chargement et inspection des donn√©es

Pour le chargement d'un fichier `.csv`, nous allons utiliser le package **{readr}** qui optimise la lecture des fichiers. On charge simultan√©ment **{dplyr}** qui facilite la manipulation de donn√©es tabulaires.

```{r}
#| message: false
#| warning: false
library(readr)
library(dplyr)
```

Le fichier utilise le point-virgule comme s√©parateur (comme souvent pour les fichiers issus de producteur de donn√©es fran√ßais), il faut donc le lire avec `read_csv2()` plut√¥t qu‚Äôavec `read_csv()`.

```{r}
#| message: false
#| warning: false
arretes <- read_csv2("../data/bor_affichage-reglementaire.csv")
```

On peut regarder d'un coup d‚Äô≈ìil les dimensions et le contenu du tableau.

```{r}
glimpse(arretes)
```

On visualise ensuite les premi√®res lignes.

```{r}
head(arretes, n = 2) %>% knitr::kable()
```

On voit que l'essentiel des informations est contenu de mani√®re non-structur√©e dans la colonne **`` arretes$`Intitul√© de l‚Äôacte` ``** (qui poss√®de au passage un nom peu pratique √† manipuler dans du code). Il y a par ailleurs des colonnes qui ne nous serviront pas.

On s√©lectionnera et renommera ainsi les colonnes :

```{r}
arretes <- arretes %>% 
  select(nature=`Nature de l'acte`, 
         numero=`Num√©ro de l'acte`, 
         intitule=`Intitul√© de l'acte`, 
         date=`Date d'affichage`)
```

## Extraction d'informations

### L'ann√©e de publication des actes

La premi√®re extraction que l'on va faire concerne la date de publication des arr√™t√©s afin de voir la p√©riode couverte par notre base de donn√©es. La colonne `arretes$date` contient l'information qui nous int√©resse avec une granularit√© temporelle cependant trop fine.

```{r}
arretes$date[1:10]
```

Pour extraire l'information qui nous int√©resse, on peut se focaliser sur les 4 premiers caract√®res de la date qui correspondent √† l'ann√©e.

```{r}
arretes$annee <- substr(arretes$date,1, 4)

arretes_annee <- arretes %>% 
  group_by(annee) %>% 
  summarise(n=n())
```

On pourra repr√©senter cette information par un graphique.

```{r}
library(ggplot2)

ggplot()+
  geom_col(data = arretes_annee, aes(x=annee, y=n))+
  labs(y="Nombre d'actes", 
       x="Ann√©e")
```

### Les types d'acte

La difficult√© principale de l'exercice r√©side dans l'extraction d'informations non-structur√©es des cha√Ænes de caract√®res qui composent le titre des actes. Pour commencer ce travail, on va d'abord en visualiser quelques-unes afin de voir si on peut d√©gager des √©l√©ments de structuration.

```{r}
arretes$intitule[sample(1:nrow(arretes), 5)]
```

On voit que le type d'acte figure en d√©but de cha√Æne, s√©par√© du reste par un tiret (`-`). On peut mobiliser une **expression r√©guli√®re** (***regex***) pour extraire du texte qui suit un pattern identifi√©.

::: callout-note
### üîç Les expressions r√©guli√®res (regex)

Une **regex** (*regular expression*) est une **cha√Æne de caract√®res sp√©ciale** qui permet de **d√©crire un motif** (ou *pattern*) dans du texte.\
Elles sont tr√®s utiles pour :

-   rechercher (`str_detect()`),

-   extraire (`str_extract()`),

-   remplacer (`str_replace()`),

-   ou d√©couper (`str_split()`)

des morceaux de texte selon une **r√®gle de forme**, et non un mot exact.

En R, on les utilise souvent avec le package **{stringr}**.
:::

::: callout-tip
### ‚öôÔ∏è Exemple : extraire ce qu‚Äôil y a avant un tiret

Supposons que nous ayons un vecteur de cha√Ænes de caract√®res :

```{r}
library(stringr)

x <- c("Bordeaux - Gironde", "Lyon - Rh√¥ne", "Marseille - Bouches-du-Rh√¥ne")
```

**√âtape 1 : la regex**

Le motif √† d√©crire est : "tous les caract√®res avant un tiret"

üëâ En regex, cela s‚Äô√©crit : `^[^-]+`

-   `^` ‚Üí d√©but de la cha√Æne

-   `[]` ‚Üí ensemble de caract√®res

-   `[^ ]` ‚Üí tout sauf ce qui est entre les crochets

-   `+` ‚Üí r√©p√®te 1 ou plusieurs fois

**√âtape 2 : l‚Äôappliquer avec** `str_extract()`

```{r}
str_extract(x, "^[^-]+")
```

On peut ensuite **supprimer les espaces** avec `str_trim()` :

```{r}
str_trim(str_extract(x, "^[^-]+"))
```
:::

Appliqu√© aux titres des actes publi√©s par la ville de Bordeaux, on aura donc :

```{r}
arretes$type <- str_trim(tolower(str_extract(arretes$intitule, "^[^-]+")))

sample(arretes$type, 10)
```

On peut √©galement compl√©ter cette identification par une variable qui rep√®re quand la cha√Æne de caract√®re correspondant √† l'intitul√© de l'acte comporte "*immeuble*" ou "*habitation*".

```{r}
arretes <- arretes %>% 
  mutate(immeuble=grepl("immeuble|habitation", tolower(intitule)))
```

Si on combine les deux colonnes, on peut voir quels types d'arr√™t√©s mentionnent fr√©quemment des immeubles ou des habitations.

```{r}
#| message: false
#| warning: false
arretes_type_immeubles <- arretes %>% 
  group_by(type, immeuble) %>% 
  summarise(n=n()) %>% 
  arrange(desc(immeuble), desc(n))

arretes_type_immeubles %>% head(n = 10) %>% knitr::kable()
```

Apr√®s une inspection manuelle, on voit que les types d'arr√™t√©s relatifs √† la d√©gradation des immeubles sont les suivants :

```{r}
arretes_selec <- arretes_type_immeubles$type[c(1,2,4,5:8,10,11,13:15,22,54,99,100,106)]
```

On cr√©e donc un nouvel objet avec uniquement les arr√™t√©s relatifs √† des immeubles.

```{r}
perils <- arretes %>% 
  filter(type %in% arretes_selec)
```

Enfin, on ne veut travailler que sur la distribution spatiale des p√©rils, peu importe s'ils ont √©t√© trait√©s ou non. On retire donc des donn√©es tout ce qui rel√®ve des mainlev√©es.

```{r}
perils <- perils %>% 
  filter(!grepl("mainlev", tolower(intitule)))
```

### La localisation des arr√™t√©s

Pour localiser les arr√™tes, il va falloir extraire les adresses et les g√©ocoder. On commence pour cela par d√©finir la liste des types de voies que l‚Äôon souhaite d√©tecter :

```{r}
types_voie <- c("rue", "avenue", "boulevard", "bd", "chemin", "impasse", "place", "quai", "all√©e", "cours")
```

On construit ensuite une expression r√©guli√®re qui cherche une structure du type\
num√©ro + (optionnellement "bis", "ter", etc.) + type de voie + nom de voie :

```{r}
pattern <- paste0(
  "\\b\\d+\\s?(?:bis|ter|quater)?\\s+(", 
  paste(types_voie, collapse = "|"), 
  ")\\s+[[:alpha:]][[:alnum:]\\s\\-']+"
)
```

On applique cette regex √† la colonne `intitule` pour extraire les adresses :

```{r}
adresses <- str_extract(tolower(perils$intitule), regex(pattern, ignore_case = TRUE) )

head(adresses)
```

Enfin, on nettoie le r√©sultat en retirant la mention "√† Bordeaux" et les espaces inutiles :

```{r}
perils$adresse <- trimws(gsub("√† bordeaux", "", adresses))
```

Le r√©sultat est une colonne `adresse` propre, contenant les adresses d√©tect√©es automatiquement dans le texte.

## La transformation de donn√©es tabulaires en donn√©es spatiales

### G√©ocodage

On commence par charger le package `banR`, qui permet de g√©ocoder des adresses √† partir de la Base Adresse Nationale (BAN).

```{r}
library(banR)
```

Avant de lancer le g√©ocodage, on ajoute une colonne contenant le code INSEE de la commune de Bordeaux.\
Cela permet de restreindre la recherche √† cette seule commune et d‚Äôobtenir des r√©sultats plus pr√©cis.

```{r}
perils$code_insee <- "33063"
```

On lance ensuite le g√©ocodage √† l‚Äôaide de la fonction `geocode_tbl()`, en pr√©cisant la colonne contenant les adresses (`adresse`) et celle avec le code INSEE (`code_insee`).

```{r}
perils_geo <- geocode_tbl(perils, adresse = adresse, code_insee = code_insee)
```

### Transformation en objet spatial

On charge d‚Äôabord les packages n√©cessaires :

-   `sf` pour manipuler des donn√©es spatiales,

-   `mapview` pour visualiser les points sur une carte interactive.

```{r}
#| message: false
#| warning: false
library(sf) 
library(mapview)
```

On filtre les r√©sultats pour ne garder que les adresses qui ont bien √©t√© g√©ocod√©es (c‚Äôest-√†-dire celles dont la longitude n‚Äôest pas manquante).

```{r}
perils_geo <- perils_geo %>% filter(!is.na(longitude))
```

On transforme ensuite le tableau en un objet spatial (`sf`) en pr√©cisant les colonnes de coordonn√©es et le syst√®me de projection (ici WGS84, EPSG:4326).

```{r}
perils_geo_sf <- st_as_sf(perils_geo, coords = c("longitude", "latitude")) %>% 
  st_set_crs(4326)
```

Enfin, on visualise les points sur une carte interactive, color√©s selon l‚Äôann√©e.

```{r}
mapview(perils_geo_sf, zcol = "annee", cex = 4)
```
